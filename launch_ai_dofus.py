#!/usr/bin/env python3
"""
üöÄ IA DOFUS - Lanceur Principal
Premier syst√®me d'IA DOFUS autonome et √©volutive
Optimis√© pour AMD 7800XT + Windows 11
"""

import asyncio
import sys
import os
import json
import logging
from pathlib import Path
import argparse
import time
from datetime import datetime

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('logs/ai_dofus.log') if Path('logs').exists() else logging.NullHandler()
    ]
)

logger = logging.getLogger("IA_DOFUS")

class AIDoFusLauncher:
    """Lanceur principal de l'IA DOFUS"""

    def __init__(self):
        self.project_root = Path(__file__).parent
        self.config_dir = self.project_root / "config"
        self.logs_dir = self.project_root / "logs"

        # Cr√©ation dossiers n√©cessaires
        self.config_dir.mkdir(exist_ok=True)
        self.logs_dir.mkdir(exist_ok=True)

        # √âtat du syst√®me
        self.systems_ready = False
        self.gpu_available = False
        self.orchestrator = None

    def display_banner(self):
        """Affiche le banner de d√©marrage"""
        banner = """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                           üöÄ IA DOFUS v1.0                                  ‚ïë
‚ïë                    Premi√®re IA Autonome & √âvolutive                         ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  üß† Core AI Framework    üéØ Vision Hybride    ‚ö° AMD 7800XT Optimis√©       ‚ïë
‚ïë  ü§î Uncertainty Mgmt     üîÆ Predictive AI     ü§ù Social Intelligence        ‚ïë
‚ïë                                                                              ‚ïë
‚ïë                        Pr√™t √† r√©volutionner DOFUS ! üéÆ                     ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""
        print(banner)

    async def check_system_requirements(self) -> bool:
        """V√©rifie les pr√©requis syst√®me"""
        print("üîç V√©rification des pr√©requis syst√®me...")

        checks = []

        # V√©rification Python
        python_version = f"{sys.version_info.major}.{sys.version_info.minor}"
        python_ok = sys.version_info >= (3, 8)
        checks.append(("Python >= 3.8", python_ok, f"Version: {python_version}"))

        # V√©rification d√©pendances critiques
        critical_modules = [
            ("torch", "PyTorch"),
            ("cv2", "OpenCV"),
            ("numpy", "NumPy"),
            ("asyncio", "AsyncIO")
        ]

        for module_name, display_name in critical_modules:
            try:
                __import__(module_name)
                checks.append((display_name, True, "Disponible"))
            except ImportError:
                checks.append((display_name, False, "Non install√©"))

        # V√©rification GPU AMD
        try:
            import torch_directml
            if torch_directml.is_available():
                self.gpu_available = True
                checks.append(("GPU AMD DirectML", True, "Disponible"))
            else:
                checks.append(("GPU AMD DirectML", False, "Non disponible"))
        except ImportError:
            checks.append(("GPU AMD DirectML", False, "torch-directml non install√©"))

        # V√©rification modules IA custom
        custom_modules = [
            ("core.ai_framework", "Core AI Framework"),
            ("core.uncertainty", "Uncertainty System")
        ]

        for module_path, display_name in custom_modules:
            try:
                __import__(module_path)
                checks.append((display_name, True, "Charg√©"))
            except ImportError as e:
                checks.append((display_name, False, f"Erreur: {e}"))

        # Affichage r√©sultats
        print("\nüìã R√©sultats des v√©rifications:")
        all_critical_ok = True

        for check_name, status, details in checks:
            status_emoji = "‚úÖ" if status else "‚ùå"
            print(f"  {status_emoji} {check_name}: {details}")

            # V√©rification si critique
            if check_name in ["Python >= 3.8", "PyTorch", "OpenCV", "Core AI Framework"]:
                if not status:
                    all_critical_ok = False

        if not all_critical_ok:
            print("\n‚ùå Des pr√©requis critiques manquent !")
            print("üîß Ex√©cutez d'abord: python scripts/setup_amd_environment.py")
            return False

        print(f"\n‚úÖ Syst√®me pr√™t ! GPU AMD: {'Disponible' if self.gpu_available else 'Indisponible'}")
        self.systems_ready = True
        return True

    async def initialize_ai_systems(self) -> bool:
        """Initialise les syst√®mes IA"""
        print("\nüß† Initialisation des syst√®mes IA...")

        try:
            # Import des modules IA
            from core.ai_framework import MetaOrchestrator
            from core.uncertainty import UncertaintyManager

            # Configuration
            config_file = self.config_dir / "ai_config.json"
            if config_file.exists():
                with open(config_file, 'r') as f:
                    config = json.load(f)
                print(f"‚úÖ Configuration charg√©e: {config_file}")
            else:
                print("‚ö†Ô∏è Configuration par d√©faut utilis√©e")
                config = {}

            # Initialisation orchestrateur principal
            print("  üé≠ D√©marrage MetaOrchestrator...")
            self.orchestrator = MetaOrchestrator(str(config_file) if config_file.exists() else None)

            if await self.orchestrator.start():
                print("  ‚úÖ MetaOrchestrator actif")
            else:
                print("  ‚ùå √âchec d√©marrage MetaOrchestrator")
                return False

            # Initialisation syst√®me d'incertitude
            print("  ü§î Initialisation Uncertainty Manager...")
            uncertainty_manager = UncertaintyManager(config.get('uncertainty', {}))
            print("  ‚úÖ Uncertainty Manager actif")

            # Test int√©gration
            print("  üß™ Test d'int√©gration...")
            await asyncio.sleep(1.0)

            status = self.orchestrator.get_status()
            if status['running']:
                print("  ‚úÖ Tous les syst√®mes op√©rationnels")
                return True
            else:
                print("  ‚ùå Probl√®me d√©tect√© lors du test")
                return False

        except Exception as e:
            logger.error(f"Erreur initialisation syst√®mes IA: {e}")
            print(f"  ‚ùå Erreur: {e}")
            return False

    async def load_vision_systems(self) -> bool:
        """Charge les syst√®mes de vision"""
        print("\nüëÅÔ∏è Chargement des syst√®mes de vision...")

        try:
            # Test chargement vision hybride
            vision_modules = [
                ("modules.vision.screen_analyzer", "Screen Analyzer"),
                ("modules.vision.hybrid_detector", "Hybrid Detector"),
                ("modules.vision.detection_adapter", "Detection Adapter")
            ]

            loaded_modules = []

            for module_path, display_name in vision_modules:
                try:
                    module = __import__(module_path, fromlist=[''])
                    loaded_modules.append(display_name)
                    print(f"  ‚úÖ {display_name} charg√©")
                except ImportError as e:
                    print(f"  ‚ö†Ô∏è {display_name} non disponible: {e}")

            if len(loaded_modules) >= 2:
                print(f"  ‚úÖ Syst√®mes de vision pr√™ts ({len(loaded_modules)}/3 modules)")
                return True
            else:
                print(f"  ‚ö†Ô∏è Vision partielle ({len(loaded_modules)}/3 modules)")
                return False

        except Exception as e:
            logger.error(f"Erreur chargement vision: {e}")
            print(f"  ‚ùå Erreur vision: {e}")
            return False

    async def run_self_diagnostics(self) -> bool:
        """Lance l'auto-diagnostic du syst√®me"""
        print("\nüî¨ Auto-diagnostic du syst√®me...")

        try:
            # Test performance basic
            print("  ‚ö° Test performance...")
            start_time = time.perf_counter()

            # Test calcul
            import numpy as np
            test_array = np.random.randn(1000, 1000)
            result = np.dot(test_array, test_array.T)

            performance_time = time.perf_counter() - start_time
            print(f"  üìä Performance CPU: {performance_time:.4f}s")

            # Test GPU si disponible
            if self.gpu_available:
                try:
                    import torch
                    import torch_directml

                    device = torch_directml.device()
                    start_time = time.perf_counter()

                    x = torch.randn(1000, 1000, device=device)
                    result_gpu = torch.mm(x, x.T)

                    gpu_time = time.perf_counter() - start_time
                    speedup = performance_time / gpu_time
                    print(f"  üöÄ Performance GPU: {gpu_time:.4f}s (acc√©l√©ration: {speedup:.2f}x)")

                except Exception as e:
                    print(f"  ‚ö†Ô∏è Test GPU √©chou√©: {e}")

            # Test m√©moire
            import psutil
            process = psutil.Process()
            memory_mb = process.memory_info().rss / 1024 / 1024
            print(f"  üíæ Utilisation m√©moire: {memory_mb:.1f} MB")

            # Test orchestrateur
            if self.orchestrator:
                status = self.orchestrator.get_status()
                modules_healthy = status.get('modules_healthy', 0)
                print(f"  üé≠ Modules IA sains: {modules_healthy}")

            print("  ‚úÖ Auto-diagnostic termin√©")
            return True

        except Exception as e:
            logger.error(f"Erreur auto-diagnostic: {e}")
            print(f"  ‚ùå Erreur diagnostic: {e}")
            return False

    async def start_ai_mode(self, mode: str = "demo"):
        """D√©marre l'IA en mode sp√©cifi√©"""
        print(f"\nüöÄ D√©marrage IA DOFUS - Mode: {mode.upper()}")

        if mode == "demo":
            await self._run_demo_mode()
        elif mode == "autonomous":
            await self._run_autonomous_mode()
        elif mode == "training":
            await self._run_training_mode()
        else:
            print(f"‚ùå Mode inconnu: {mode}")

    async def _run_demo_mode(self):
        """Mode d√©monstration"""
        print("üéÆ Mode D√©monstration - Affichage des capacit√©s IA")

        demo_tasks = [
            "Initialisation des modules de perception",
            "Test de prise de d√©cision",
            "Simulation d'incertitude",
            "D√©monstration d'apprentissage",
            "Test de coordination"
        ]

        for i, task in enumerate(demo_tasks, 1):
            print(f"  {i}/5 {task}...")
            await asyncio.sleep(2.0)  # Simulation
            print(f"  ‚úÖ {task} termin√©")

        print("\nüéâ D√©monstration termin√©e ! L'IA DOFUS est op√©rationnelle.")

    async def _run_autonomous_mode(self):
        """Mode autonome complet"""
        print("ü§ñ Mode Autonome - IA DOFUS en action")
        print("‚ö†Ô∏è Mode non encore impl√©ment√© - En d√©veloppement Phase 1")

    async def _run_training_mode(self):
        """Mode entra√Ænement"""
        print("üéì Mode Entra√Ænement - Apprentissage adaptatif")
        print("‚ö†Ô∏è Mode non encore impl√©ment√© - En d√©veloppement Phase 2")

    async def shutdown(self):
        """Arr√™t propre du syst√®me"""
        print("\nüõë Arr√™t de l'IA DOFUS...")

        if self.orchestrator:
            await self.orchestrator.stop()
            print("  ‚úÖ MetaOrchestrator arr√™t√©")

        print("  ‚úÖ Arr√™t termin√©")

    async def run(self, mode: str = "demo", skip_checks: bool = False):
        """Ex√©cution principale"""
        self.display_banner()

        try:
            # V√©rifications syst√®me
            if not skip_checks:
                if not await self.check_system_requirements():
                    return False

            # Initialisation
            if not await self.initialize_ai_systems():
                print("‚ùå √âchec initialisation IA")
                return False

            # Vision (optionnel)
            await self.load_vision_systems()

            # Auto-diagnostic
            await self.run_self_diagnostics()

            # D√©marrage mode s√©lectionn√©
            await self.start_ai_mode(mode)

            return True

        except KeyboardInterrupt:
            print("\n‚ö†Ô∏è Interruption utilisateur")
            return True
        except Exception as e:
            logger.error(f"Erreur critique: {e}")
            print(f"üí• Erreur critique: {e}")
            return False
        finally:
            await self.shutdown()

async def main():
    """Point d'entr√©e principal"""
    parser = argparse.ArgumentParser(description="üöÄ IA DOFUS - Syst√®me Autonome")

    parser.add_argument(
        "--mode",
        choices=["demo", "autonomous", "training"],
        default="demo",
        help="Mode de fonctionnement (d√©faut: demo)"
    )

    parser.add_argument(
        "--skip-checks",
        action="store_true",
        help="Ignore les v√©rifications syst√®me"
    )

    parser.add_argument(
        "--test-only",
        action="store_true",
        help="Lance uniquement les tests d'int√©gration"
    )

    args = parser.parse_args()

    if args.test_only:
        print("üß™ Mode test uniquement")
        os.system("python scripts/test_amd_integration.py")
        return

    # Lancement principal
    launcher = AIDoFusLauncher()
    success = await launcher.run(args.mode, args.skip_checks)

    if success:
        print("\nüéâ IA DOFUS s'est ex√©cut√©e avec succ√®s !")
        print("\nüéØ PROCHAINES √âTAPES:")
        print("1. python scripts/gemini_consensus.py autonomy_architecture")
        print("2. Investigation Dofus Guide/Ganymede")
        print("3. D√©veloppement Phase 1: Knowledge Base")
    else:
        print("\n‚ùå Probl√®mes d√©tect√©s. Consultez les logs.")
        print("\nüîß ACTIONS CORRECTIVES:")
        print("1. python scripts/setup_amd_environment.py")
        print("2. python scripts/test_amd_integration.py")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nüëã Au revoir !")
    except Exception as e:
        print(f"üí• Erreur fatale: {e}")
        sys.exit(1)